#!/usr/bin/env python

"""Find overflows associated with a particular front-end model
"""

import argparse
import numpy
import os.path

from gwpy.timeseries import (TimeSeries, TimeSeriesDict)
from gwpy.io.cache import cache_segments

from gwdetchar import (cli, const, overflow)
from gwdetchar.io import (datafind, ligolw)


def table_from_times(times, channel):
    return ligolw.sngl_burst_from_times(
        times, snr=10, peak_frequency=100, channel=channel,
        search=os.path.basename(__file__))


parser = argparse.ArgumentParser(description=__doc__)
cli.add_gps_start_stop_arguments(parser)
cli.add_ifo_option(parser)
parser.add_argument('dcuid', type=int, nargs='+',
                    help='DCUID for the relevant front-end model')
cli.add_frametype_option(parser, required=const.IFO is None,
                         default=const.IFO is not None and '%s_R' % const.IFO)
cli.add_nproc_option(parser)
parser.add_argument('--deep', action='store_true', default=False,
                    help='perform deep scan, default: %(default)s')

args = parser.parse_args()

# get frame cache
cache = datafind.find_frames(args.ifo[0], args.frametype,
                             args.gpsstart.seconds, args.gpsend.seconds)
cachesegs = cache_segments(cache)

# get channel and find overflows
table = None
for dcuid in args.dcuid:
    channel = overflow.ligo_accum_overflow_channel(dcuid, args.ifo)
    for seg in cachesegs:
        seg &= type(seg)(args.gpsstart, args.gpsend)
        c = cache.sieve(segment=seg)
        data = TimeSeries.read(c, channel, nproc=args.nproc,
                               start=seg[0], end=seg[1])
        times = overflow.find_overflows(data)

        if args.deep and times.size > 0:
            channels = overflow.ligo_model_overflow_channels(
                dcuid, args.ifo, args.frametype, gpstime=int(times[0]))
            for t in times:
                data = TimeSeriesDict.read(c, channels, nproc=args.nproc,
                                           start=int(t-1), end=int(t+1))
                for ch in channels:
                    times = overflow.find_overflows(data[ch])
                    if table is None:
                        table = table_from_times(times, ch)
                        extend = table.extend
                    else:
                        extend(table_from_times(times, ch))
        else:
            if table is None:
                table = table_from_times(times, channel)
                extend = table.extend
            else:
                extend(table_from_times(times, channel))

ligolw.table_to_document(table).write()
