# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2015-)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

"""Find overflows associated with a particular front-end model
"""

import argparse
import numpy
import os.path

from gwpy.timeseries import (TimeSeries, TimeSeriesDict)
from gwpy.io.cache import cache_segments

from gwdetchar import (cli, const, overflow, version)
from gwdetchar.io import (datafind, ligolw)

__author__ = 'TJ Massinger <thomas.massinger@ligo.org>'
__credits__ = 'Duncan Macleod <duncan.macleod@ligo.org>'
__version__ = version.version

def table_from_times(times, channel):
    return ligolw.sngl_burst_from_times(
        times, snr=10, peak_frequency=100, channel=channel,
        search=os.path.basename(__file__))


parser = argparse.ArgumentParser(description=__doc__)
cli.add_gps_start_stop_arguments(parser)
cli.add_ifo_option(parser)
parser.add_argument('dcuid', type=int, nargs='+',
                    help='DCUID for the relevant front-end model')
cli.add_frametype_option(parser, required=const.IFO is None,
                         default=const.IFO is not None and '%s_R' % const.IFO)
cli.add_nproc_option(parser)
parser.add_argument('--deep', action='store_true', default=False,
                    help='perform deep scan, default: %(default)s')

args = parser.parse_args()

# get frame cache
cache = datafind.find_frames(args.ifo[0], args.frametype,
                             args.gpsstart.seconds, args.gpsend.seconds)
cachesegs = cache_segments(cache)

# get channel and find overflows
table = None
for dcuid in args.dcuid:
    channel = overflow.ligo_accum_overflow_channel(dcuid, args.ifo)
    for seg in cachesegs:
        seg &= type(seg)(args.gpsstart, args.gpsend)
        c = cache.sieve(segment=seg)
        data = TimeSeries.read(c, channel, nproc=args.nproc,
                               start=seg[0], end=seg[1])
        times = overflow.find_overflows(data)

        if args.deep and times.size > 0:
            channels = overflow.ligo_model_overflow_channels(
                dcuid, args.ifo, args.frametype, gpstime=int(times[0]))
            for t in times:
                data = TimeSeriesDict.read(c, channels, nproc=args.nproc,
                                           start=int(t-1), end=int(t+1))
                for ch in channels:
                    times = overflow.find_overflows(data[ch])
                    if table is None:
                        table = table_from_times(times, ch)
                        extend = table.extend
                    else:
                        extend(table_from_times(times, ch))
        else:
            if table is None:
                table = table_from_times(times, channel)
                extend = table.extend
            else:
                extend(table_from_times(times, channel))

ligolw.table_to_document(table).write()
