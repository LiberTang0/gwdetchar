#!/usr/bin/env python
# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2015-)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

"""Search for evidence of beam scattering based on optic velocity
"""

import os.path
import argparse
import re
from StringIO import StringIO

import numpy

from gwpy.plotter import (figure, HistogramPlot)
from gwpy.utils.compat import OrderedDict
from gwpy.timeseries import TimeSeries
from gwpy.segments import (DataQualityFlag, DataQualityDict,
                           Segment, SegmentList)

from gwdetchar import (cli, const, scattering, version)
from gwdetchar.io import html as htmlio

__author__ = 'Duncan Macleod <duncan.macleod@ligo.org>'
__version__ = version.version

# -- parse command line -------------------------------------------------------

parser = argparse.ArgumentParser(description=__doc__)
cli.add_gps_start_stop_arguments(parser)
cli.add_ifo_option(parser)
parser.add_argument('-a', '--state-flag', metavar='FLAG',
                    help='restrict search to times when FLAG was active')
parser.add_argument('-t', '--frequency-threshold', type=float, default=40,
                    help='critical fringe frequency threshold (in Hertz), '
                         'default: 10')
parser.add_argument('-x', '--multiplier-for-threshold', type=int,
                    default=4, choices=scattering.FREQUENCY_MULTIPLIERS,
                    help='fringe frequency multiplier to use when applying '
                         '--frequency-threshold, default: %(default)s')
parser.add_argument('-m', '--optic', action='append',
                    help='optic to search for scattering signal, can be given '
                         'multiple times, default: %s'
                         % scattering.OPTIC_MOTION_CHANNELS.keys())
parser.add_argument('-o', '--output-dir', type=os.path.abspath,
                    default=os.curdir,
                    help='output directory for analysis, default: %(default)s')
parser.add_argument('-v', '--verbose', action='store_true', default=False,
                    help='print verbose output, default: %(default)s')
cli.add_nproc_option(parser)

args = parser.parse_args()

if args.frequency_threshold.is_integer():
    args.frequency_threshold = int(args.frequency_threshold)

tstr = str(args.frequency_threshold).replace('.', '_')
gpsstr = '%s-%s' % (args.gpsstart.seconds, (args.gpsend-args.gpsstart).seconds)

if args.optic is None:
    args.optic = scattering.OPTIC_MOTION_CHANNELS.keys()

if not os.path.isdir(args.output_dir):
    os.makedirs(args.output_dir)
os.chdir(args.output_dir)

segxml = '%s-SCATTERING_SEGMENTS_%s_HZ-%s.xml.gz' % (args.ifo, tstr, gpsstr)

# -- get state segments -------------------------------------------------------

span = Segment(args.gpsstart, args.gpsend)

# get segments
if args.state_flag:
    state = DataQualityFlag.query(args.state_flag, args.gpsstart.seconds,
                                  args.gpsend.seconds,
                                  url=const.O1_SEGMENT_SERVER)
    statea = state.active
    if args.verbose:
        print("Downloaded %d segments for %s [%.2fs livetime]"
              % (len(statea), args.state_flag, abs(statea)))
else:
    statea = SegmentList([span])

# -- prepare HTML -------------------------------------------------------------

page = htmlio.new_bootstrap_page(title='%s scattering' % args.ifo)
page.div(class_='container')
page.div(class_='page-header')
page.h1('%s scattering: %d-%d'
        % (args.ifo, args.gpsstart.seconds, args.gpsend.seconds))
page.p("This analysis searched for evidence of beam scattering based on the "
       "velocity of optic motion. The fringe frequency is predicted using "
       "equation (3) of <a href=\"http://iopscience.iop.org/article/10.1088/"
       "0264-9381/27/19/194011\">Accadia et al. (2010)</a>.")
page.div.close()

# link XML file
page.p()
page.add('The full output segments are recorded in '
         'LIGO_LW-format XML here:')
page.a(os.path.basename(segxml), href=segxml, target='_blank')
page.p.close()
# print state segments
if args.state_flag:
    page.p('This analysis was executed over the following segments:')
    page.div(class_='panel-group', id_='accordion1')
    page.add(str(htmlio.write_flag_html(state, 'state', parent='accordion1',
                                        context='success', id='state')))
    page.div.close()

page.p("The following channels were search for evidence of scattering "
       "(yellow = weak evidence, red = strong evidence")
page.div(class_='panel-group', id_='accordion1')

# -- find scattering evidence -------------------------------------------------

allchannels = ['%s:%s' % (args.ifo, c) for optic in args.optic for
               c in scattering.OPTIC_MOTION_CHANNELS[optic]]

scatter_segments = DataQualityDict()

for i, channel in enumerate(sorted(allchannels)):
    print("-- Processing %s --" % channel)
    # set up plot(s)
    plot = figure(figsize=[12, 6])
    axes = {}
    axes['position'] = plot.add_subplot(311, projection='timeseries')
    axes['fringef'] = plot.add_subplot(312, projection='timeseries',
                                       sharex=axes['position'])
    axes['segments'] = plot.add_subplot(313, projection='segments',
                                        sharex=axes['position'])
    histdata = dict((i, numpy.ndarray((0,))) for
                    i in scattering.FREQUENCY_MULTIPLIERS)
    linecolor = None
    fringecolors = [None] * len(scattering.FREQUENCY_MULTIPLIERS)
    # loop over state segments and find scattering fringes
    for segstart, segend in statea:
        print("Processing segment [%d .. %d)" % (segstart, segend))
        # get raw data and plot
        ts = TimeSeries.get(channel, segstart, segend, nproc=args.nproc)
        if args.verbose:
            print("    Retrieved data.")
        line = axes['position'].plot(ts, color=linecolor)[0]
        linecolor = line.get_color()
        # get fringe frequency and plot
        fringef = scattering.get_fringe_frequency(ts, multiplier=1)
        for j, m in enumerate(scattering.FREQUENCY_MULTIPLIERS):
            fm = fringef * m
            line = axes['fringef'].plot(fm, color=fringecolors[j])[0]
            fringecolors[j] = line.get_color()
            histdata[m].resize((histdata[m].size + fm.size,))
            histdata[m][-fm.size:] = fm.value
        # get segments and plot
        scatter = (
            fringef * args.multiplier_for_threshold >=
            args.frequency_threshold * fringef.unit).to_dqflag()
        axes['segments'].plot(scatter, facecolor='red', edgecolor='darkred',
                              known={'alpha': 0.1, 'facecolor': 'lightgray'},
                              y=0, label=' ')
        scatter_segments[channel] = scatter
        if args.verbose:
            print("    Found %d scattering segments" % (len(scatter.active)))

    # finalize plot
    axes['position'].set_title("Scattering evidence in %s"
                               % channel.replace('_', r'\_'))
    axes['position'].set_xlabel('')
    axes['position'].set_ylabel(r'Position [\textmu m]')
    axes['fringef'].plot(
        span, [args.frequency_threshold, args.frequency_threshold], 'k--')
    axes['fringef'].set_xlabel('')
    axes['fringef'].set_ylabel(r'Frequency [Hz]')
    axes['segments'].set_ylim(-.5, .5)
    axes['fringef'].yaxis.tick_right()
    axes['fringef'].yaxis.set_label_position("right")
    for ax in axes.values():
        ax.set_epoch(args.gpsstart.seconds)
        ax.set_xlim(*span)
    chanstr = re.sub('[:-]', '_', channel).replace('_', '-', 1)
    png = '%s_SCATTERING_%s_HZ-%s.png' % (chanstr, tstr, gpsstr)
    plot.save(png)

    # make histogram
    histogram = HistogramPlot(figsize=[8, 6])
    ax = histogram.gca()
    hrange = ax.common_limits(histdata.values())
    for m, color in zip(histdata, fringecolors):
        ax.hist(histdata[m], facecolor=color, alpha=.6, range=hrange, bins=50,
                histtype='stepfilled', label=r'$f\times%d$' % m)
    ax.set_ylabel('Histogram counts')
    ax.set_xlabel('Frequency [Hz]')
    ax.legend(loc='upper right')
    histogram.save('%s_SCATTERING_HISTOGRAM-%s.png' % (chanstr, gpsstr))

    # write HTML
    if (histdata[args.multiplier_for_threshold].max() >=
            args.frequency_threshold):
        context = 'danger'
    elif (histdata[args.multiplier_for_threshold].max() >=
            args.frequency_threshold/2.):
        context = 'warning'
    else:
        context = 'default'
    page.div(class_='panel panel-%s' % context)
    page.div(class_='panel-heading')
    page.a(channel, class_="panel-title", href='#flag%s' % i,
           **{'data-toggle': 'collapse', 'data-parent': '#accordion'})
    page.div.close()
    page.div(id_='flag%s' % i, class_='panel-collapse collapse')
    page.div(class_='panel-body')
    segs = StringIO()
    if len(scatter_segments[channel].active):
        page.p("This channel showed evidence of scattering above %.2f Hz "
               "during the following segments" % args.frequency_threshold)
        scatter_segments[channel].active.write(segs, format='segwizard',
                                               coltype=float)
        page.pre(segs.getvalue())
    else:
        page.p("No segments were found with scattering above %.2f Hz."
               % args.frequency_threshold)
    page.div.close()
    page.a(href=png, target='_blank')
    page.img(style="width: 100%;", src=png)
    page.a.close()
    page.div.close()
    page.div.close()

# -- finalize -----------------------------------------------------------------

# write segments
scatter_segments.write(segxml)
print("%s written" % segxml)

# write HTML
page.div.close()
with open('index.html', 'w') as fp:
    fp.write(str(page))
